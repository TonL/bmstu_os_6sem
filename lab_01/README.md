Не понравились использованные функции для определения времени, так что лучше исправить на что-то более простое.

```
Запустить демона без прав суперюзера:
    ./oslabd
Запустить демона с правами суперюзера:
    sudo ./oslabd
Найти демона в списке процессов (запомнить pid):
    ps -axj
Посмотреть log:
    tail -n 100 /var/log/syslog
Посмотреть номера сигналов:
    kill -l
Отправить SIGHUP:
    sudo kill -1 %pid%
Отправить SIGTERM:
    sudo kill -15 %pid%
```
# Вопросы
## Вопросы по ps -axj
Флаги для вывода:
- a - процессы, которыми владеют другие пользователи;
- x - процессы, которые не имеют управляющего терминала (TTY);
- j - вывод дополнительных сведений о процессах.

Идентификаторы:
- PPID - идентификатор процесса-родителя **(терминальный процесс, поскольку после вызова fork() завершился родительский процесс, и потомок был "усыновлен" терминальным процессом)**;
- PID (process id) = PGID (process group) = SID (session id);
- TTY - имя терминала;
- TPGID - идентификатор группы процессов терминала, к которому подключен процесс (-1) если нет терминала;
- STAT - состояние процесса;
    Состояния:
    - S - interruptable sleep;
    - D - uninterruptable sleep (I/O);
    - I - работа в режиме ядра.
    Доп:
    - s - лидер сессии;
    - l - многопоточный.
 - TIME - время работы процесса;
 - COMMAND - название команды, запустившей процесс (вроде).
 
У демона PID = PGID = SID, т.к. у него не должно быть управляющего терминала, и он не должен получать сигналов от процессов из своей группы/сессии.

## Очень важно

**Происходит вызов fork(), создается процесс-потомок, завершается предок. В результате этого действия потомок теряет группу (процессы, вызывающие fork() становятсся лидерами группы). Таким образом, процесс-потомок не является лидером группы, что является обязательным условием вызова setsid(). В результате всего этого демон утрачивает управляющий терминал и становится лидером группы и сессии.**

## В какой точке программы процесс становится демоном?
Указать на _вызов_ функции daemonize()
 
## Что делает already_running()?
Для обеспечения работы демона в единственном экземпляре. Осуществляется блокировкой файла в области ядра ОС, пока один процесс "держит" блокировку, другой заблокировать файл не сможет

## Почему демон должен работать в единственном экземпляре?
Демон предоставляет сервис. Не нужно предоставлять одни и те же услуги.

## Порядок действий в daemonize.
По проге и по конспекту семинара :(

## Почему нужно запускать с правами суперпользователя?
Демона нужно запускать с правами суперпользователя, чтобы можно было создать файл в области ядра ОС для обеспечения работы демона в единственном экземпляре.

## Объяснить назначение аргументов, передающихся функции блокировки файла.
У меня используется flock, первый аргумент - дескриптор открытого файла, второй - флаги (LOCK_EX - эксклюзивная блокировка, LOCK_NB - процесс не будет блокироваться в ожидании разблокировки файла, если он уже заблокирован, ака _неблокирующий запрос_). 

## Почему для обработки сигналов нужен еще один поток?
